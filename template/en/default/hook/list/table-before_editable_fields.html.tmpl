[%#
  # The contents of this file are subject to the Mozilla Public
  # License Version 1.1 (the "License"); you may not use this file
  # except in compliance with the License. You may obtain a copy of
  # the License at http://www.mozilla.org/MPL/
  #
  # Software distributed under the License is distributed on an "AS
  # IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  # implied. See the License for the specific language governing
  # rights and limitations under the License.
  #
  # The Original Code is the Scrums Bugzilla Extension.
  #
  # The Initial Developer of the Original Code is "Nokia corporation"
  # Portions created by the Initial Developer are Copyright (C) 2011 the
  # Initial Developer. All Rights Reserved.
  #
  # Contributor(s):
  #   Visa Korhonen <visa.korhonen@symbio.com>
  #%]

[% USE Bugzilla %]
[% USE date %]
[% SET select_fields = {} %]
[% FOREACH field = Bugzilla.get_fields(
  { type => constants.FIELD_TYPE_SINGLE_SELECT, custom => 0 })
%]
  [% select_fields.${field.name} = field %]
[% END %]

<script type="text/JavaScript" src="extensions/Scrums/web/js/jquery/js/jquery-1.4.4.min.js"></script>
<script type="text/JavaScript" src="extensions/Scrums/web/js/jquery/js/jquery-ui-1.8.10.custom.min.js"></script>

<script>
var editedFieldid = "";
var originalValue = "";
var originalSelectedIndex = "";

/**
 * Function finds element by it's id. First element of type 'input' is searched and returned.
 */
function getInputElementByParentId(parentId)
{
    var parentEl = document.getElementById(parentId);
    var inputsList = parentEl.getElementsByTagName("input");
    return inputsList[0];
}

/**
 * Function checks whether edited field has been changed from original value.
 * If value has changed, field is tried to be saved. Edited field is made hidden
 * static field is made visible. Static field is changed into same value, that is saved, 
 * or original value, if saving is not done.
 *
 * Editable fields of types 'input' and 'select' are handled separately.
 */
function checkIfEditedFieldChanged()
{
    var status = false;

    var editField = getInputElementByParentId(editedFieldid + "_editable");
    var newValue = "";
    if(editField)
    {
        newValue = editField.value;	
        if(newValue != originalValue)
        {
	    if(save(editedFieldid, newValue))
    	    {
    		makeInputStatic(editedFieldid, newValue); 
		status = true;
    	    }
            else
            {
    	        makeInputStatic(editedFieldid, originalValue);
		status = false;
            }
        }
        else
        {
	    makeInputStatic(editedFieldid, originalValue);
            status = false;
        }
    }
    else
    {
    // Else input is selection. Must be handled separately.
        editableEl = document.getElementById(editedFieldid + "_editable");
	var selectEl = editableEl.getElementsByTagName("select")[0];
	var selectedIndex = selectEl.selectedIndex;
	if(originalSelectedIndex != selectedIndex)
	{
	    newValue = selectEl.options[selectedIndex].value;
	    if(save(editedFieldid, newValue))
    	    {
    	        makeSelectStatic(editedFieldid, selectedIndex); 
            }
            else
            {
    	        makeSelectStatic(editedFieldid, originalSelectedIndex);
            }
	}
        else
        {
    	    makeSelectStatic(editedFieldid, originalSelectedIndex);
        }
    }

    editedFieldid = "";
    originalValue = "";
    return status;
}

/**
 * Function first asks user, if he wants to save value. Status of saving is returned.
 */
function save(fieldid, newValue) 
{
    var bugId = fieldid.match(/^\d{1,6}/);
    var fieldName = fieldid.substr(bugId[0].length + 1);
    if(confirm("Do you want to save changes in "+fieldName))
    {
	saveBugField(bugId[0], fieldName, newValue);
	return true;
    }
    else
    {
	return false;
    }
}

/**
 * Function is call-back function, that is called after succesfull ajax call returns.
 * Ajax call if succesfull, if server responds without throwing exception. Ordered
 * errors are shown in error message. Function shows status of saving to user.
 */
function saveResponse(response, status, xhr) 
{ 
	var retObj = eval("("+ response+")");
	if(retObj.errors)
	{
		alert("There are errors: "+retObj.errormsg);
	}
	else
	{
		alert("Success");
	}
}

/**
 * Function saves value of one bug field into database by doing ajax-call.
 */ 
function saveBugField(bugId, fieldName, newValue)
{
    var json_params = '{ "method": "Bug.update", "params": {"ids" : [' +bugId+ '], "' +fieldName+ '" : "' +newValue+ '"}, "id" : 0 }';

    $.post('page.cgi?id=scrums/ajax.html', {
        schema: 'bug',
        action: 'update',
        data: json_params
    }, saveResponse        , 'text');
}

/* Synchronous call for debugging */
function synchronous_saveBugField(bugId, fieldName, newValue)
{
    var json_params = '{ "method": "Bug.update", "params": {"ids" : [' +bugId+ '], "' +fieldName+ '" : "' +newValue+ '"}, "id" : 0 }';

    $.ajax({ async: false,
	url: 'page.cgi?id=scrums/ajax.html', 
	data: {
        	schema: 'bug',
        	action: 'update',
	        data: json_params },
	success: saveResponse }
    );
}

/**
 * Function makes static field hidden and editable field visible.
 * Value of edited field is stored for use in saving changed value later.
 * While initialising one field to be editable, id of that field is stored.
 *
 * Editable fields of types 'input' and 'select' are handled separately.
 */
function makeeditable(fieldid) 
{
    var status = false;

    var staticId = fieldid + "_static";
    var editableId = fieldid + "_editable";
    var staticEl = document.getElementById(staticId);
    var editableEl = document.getElementById(editableId);

    if(editedFieldid != "" && editedFieldid != fieldid)
    {
        status = checkIfEditedFieldChanged();
    }
    editedFieldid = fieldid;
    staticEl.style.visibility = 'collapse';
    editableEl.style.visibility = 'visible';
	
    var allInputs = editableEl.getElementsByTagName("input");
    if(allInputs.length > 0)
    {
	originalValue = allInputs[0].value;
    }
    else 
    {
	// Else input is selection. Must be handled separately.
	var spanEl = staticEl.getElementsByTagName("span")[0];
	var textVal = spanEl.title;
	var selectEl = editableEl.getElementsByTagName("select")[0];
	var allOptions = selectEl.options;
	var i = 0;
        for(i = 0; i < allOptions.length; i++)
        {
	    if(allOptions[i].value == textVal)
	        break;
	}
	var selectedIndex = i;
	var selectedItem = selectEl.options[selectedIndex];
	originalSelectedIndex = selectedIndex;
	originalValue = selectedItem.value;
    }
}

/**
 * Function makes static field visible and makes editable field hidden,
 * when editable field is type 'input'.
 */
function makeInputStatic(fieldid, currentvalue) 
{
    var staticId = fieldid + "_static";
    var editableId = fieldid + "_editable";
    var staticEl = document.getElementById(staticId);
    var editableEl = document.getElementById(editableId);

    staticEl.firstChild.innerHTML = currentvalue;

    staticEl.style.visibility = 'visible';
    editableEl.style.visibility = 'collapse';

    var allInputs = editableEl.getElementsByTagName("input");
    allInputs[0].value = currentvalue;
}

/**
 * Function makes static field visible and makes editable field hidden,
 * when editable field is type 'select'.
 */
function makeSelectStatic(fieldid, currentSelectedIndex) 
{
    var staticId = fieldid + "_static";
    var editableId = fieldid + "_editable";
    var staticEl = document.getElementById(staticId);
    var editableEl = document.getElementById(editableId);

    var selectEl = editableEl.getElementsByTagName("select")[0];
    selectEl.selectedIndex = currentSelectedIndex;

    var selectedItem = selectEl.options[currentSelectedIndex];
    var currentValue = selectedItem.value;

    var abbr = currentValue.substr(0, 3);
    var newText = '<span title="' + currentValue + '">' + abbr + '</span>';
    staticEl.firstChild.innerHTML = newText;

    staticEl.style.visibility = 'visible';
    editableEl.style.visibility = 'collapse';


}

</script>

